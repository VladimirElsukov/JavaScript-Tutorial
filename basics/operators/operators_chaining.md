# Безопасный доступ к вложенным объектам в JavaScript: оператор Optional Chaining (?)

Начиная с версии ECMAScript 2020, в JavaScript появился новый оператор — `Optional Chaining` (оператор необязательной цепочки), обозначаемый знаком вопроса (`?`). Этот оператор существенно облегчает жизнь разработчикам, позволяя безопасно обращаться к глубоко вложенным свойствам объектов, предотвращая возможные ошибки при обращении к несуществующим полям.

Традиционно, при попытке обратиться к полю объекта, которого не существует, возникает ошибка `TypeError`, что часто вызывает неудобства при разработке приложений. Например, если попытаться получить доступ к адресу пользователя, которого нет в профиле:

```js
const user = { name: "Иван" };
console.log(user.profile.address.city);
// TypeError: Cannot read properties of undefined (reading 'address')
```

Чтобы избежать подобной ситуации раньше приходилось добавлять дополнительные проверки существования свойств вручную:

```js
const city = user && user.profile && user.profile.address && user.profile.address.city;
```

Такое решение громоздко и снижает читабельность кода. Именно тут вступает в игру оператор `Optional Chaining`.

## Принцип работы оператора Optional Chaining

Основной смысл оператора заключается в проверке существования всех промежуточных полей перед обращением к последнему объекту. Если какое-то из промежуточных свойств не существует, оператор останавливает дальнейшие попытки обращения и возвращает специальное значение `undefined`.

Вернёмся к нашему примеру:

```js
const user = { name: "Иван" };
console.log(user.profile?.address?.city); // undefined
```

Обратите внимание на знаки вопросов перед каждым последующим полем (`profile?`, `address?`). Благодаря этому оператор остановил выполнение, увидев отсутствие поля `profile`, и вернул нам `undefined`, избежав ошибок.

## Возможности оператора Optional Chaining

### Доступ к свойствам объекта

Самый распространённый случай использования — обращение к глубоким вложениям в объектах:

```js
const person = {
  name: "Анна",
  address: {
    street: "Ленина",
    house: 10,
    apartment: 55
  }
};

console.log(person.address?.house); // 10
console.log(person.address?.office); // undefined
```

### Вызовы методов объектов

Помимо доступа к свойствам, оператор `Optional Chaining` можно использовать и для вызова методов объектов. Это полезно, если метод может отсутствовать или объект сам по себе не определен:

```js
const car = {
  brand: "Toyota",
  startEngine() {
    return "Двигатель запущен!";
  },
};

console.log(car.startEngine?.()); // Двигатель запущен!
console.log(car.openDoor?.()); // undefined
```

Метод `openDoor` не объявлен, поэтому ничего не произойдёт, кроме возвращения неопределенного значения.

### Цепочка вызовов функций

Иногда бывает удобно вызывать одну функцию после другой, особенно если предыдущие функции могут возвращать неопределённые значения:

```js
const service = {
  authService: {
    login(email, password) {
      return email.includes("@") ? { token: "valid_token" } : null;
    },
  },
};

const token = service.authService.login?.("john@example.com", "password")?.token;
console.log(token); // valid_token
```

Если бы метод `login` не существовал или возвращал бы некорректные данные, токен остался бы равным `undefined`.

### Комбинирование с Nullish Coalescing Operator (??)

Вместе с другим новым оператором `Nullish Coalescing` (`??`) оператор `Optional Chaining` даёт возможность создать мощные механизмы защиты от ошибок:

```js
const userData = {
  name: "Сергей",
  settings: {},
};

const theme = userData.settings.theme ?? "light"; // Вернет light, если настройки темы отсутствуют
console.log(theme); // light
```

Используя оба оператора вместе, вы можете одновременно проверять существование свойств и устанавливать дефолтные значения.

## Итоги

Оператор `Optional Chaining` значительно улучшает удобство разработки на JavaScript, избавляя программиста от множества рутинных проверок на наличие промежуточных полей и возможных ошибок. Он идеально подходит для ситуаций, связанных с обработкой потенциально отсутствующих свойств и методами объектов, помогая писать чистый и безопасный код.